import numpy as np
import time as tm
# timer = tm.time()
# array = np.arange(100)
# array**2
# lasttime1 = tm.time()-timer
# timer2 = tm.time()
# L = range(100)
# ali = [i ** 2 for i in L]
# lasttime2 = tm.time()-timer2
# print(lasttime2/lasttime1)
#UP casting:If  the some data-type is different the numpy upcasted this data to upper data-type
# npArr = np.array([3,4.0,5,False,"upcasting"])
# print(npArr)
# print(npArr.dtype)
# print(npArr.nbytes)
# print()
# x = np.array([3,4,5],dtype=np.int)
# print(x)
# print(x.dtype)
# print()
# y = np.array([3,4,5],dtype=np.float)
# print(y.dtype)
# print(y)
# print()
# z = np.array([3,4,5],dtype=np.str)
# print(z.dtype)
# print(z)
# print()
# t= np.array([3,4,5],dtype=np.complex)
# print(t)
# print(t.dtype)
# print()
# boolean= np.array([0,3,4,5],dtype=np.bool)
# print(boolean)
# print(boolean.dtype)
##Downcasting
# x = np.array([1.2,3.4,5.6],dtype=np.int)
# print(x)
# print(x.dtype)
## AfterCasting
# x = np.array([1.2, 3.4, 5.6],  dtype=np.float)
# print(x)
# print(x.dtype)
# x = np.array(x, np.complex)
# print(x)
# print(x.dtype)
# ##or we can do with as type
# x = x.astype(np.int)
# print(x)
# print(x.dtype)
# x1 = np.array([1,2,3],np.int)
# x2 = np.array([9,8,7],np.float)
# print(x1+x2)
# print((x1+x2).dtype)

# x = np.array([1,2,3],np.complex)
# print(x)
# print(x.dtype)
# print("Real",x.real)
# print("Imaginary",x.imag)
# print((x.real).dtype)
# x = np.array([1,2,3,16,34])
# np.save('ndarray_1', x)
# print(x)
# y = np.load('ndarray_1.npy')
#
# print(y)
# print(y.shape)
# np_zeros = np.zeros(10)
# np_ones = np.ones(10)
# x = np.zeros((2,3,4),dtype=np.int)
# print(x)
# y = np.ones((3,2))
# print(y)
# unıtMatrix = np.eye(4)
# print(unıtMatrix)
# x = np.eye(5,4)
# print(x)
# y = np.eye(6)
# print(y)
# print()
# z = np.eye(6,k=1)
# print(z)
# print()
# t = np.eye(6,k=-2)
# print(t)
# print()
#unitMatrix = np.identity(6)
#print(unitMatrix)
# diagonal = np.diag([4,7,11,13])
# print(diagonal)
# deleting an item
# x = np.arange(6)
# print(x)
# x = np.delete(x,[0,1])
# print(x)
# print()
# multi_x = np.arange(0,16).reshape(4,4)
# #if axis = 0 -> row
# #if axis = 1 -> column
# print(multi_x)
# print()
# multi_x = np.delete(multi_x,1,axis=0)
# print(multi_x)
# print()
# multi_x = np.delete(multi_x,[0,2],axis=1)
# print(multi_x)
# stack
# x = np.arange(3)
# print(x)
# print()
# y = np.arange(9).reshape(3,3)
# print(y)
# print()
# z = np.vstack((x,y))#vertical stack
# print(z)
# t = np.hstack((x,y.reshape(9,)))#horizontal stack
# print()
# print(t)
#fancy indexing
# x = np.linspace(1,21,11)
# print(x)
# print()
# y = np.array([2,4,7])
# print(y)
# print()
# z = x[y]
# print(z)
# print(np.shares_memory(x,z))
#boolean indexing
# x = np.arange(10)
# print(x)
# print()
# y = x[(x%2 == 0)]
# print(y)
#Grouping procces
# x = np.array([2,5,3,6,9])
# y = np.array([6,1,8,7,3])
# print(x)
# print()
# print(y)
# print()
# intersected = np.intersect1d(x,y)
# print(intersected)
# different1 = np.setdiff1d(x,y)
# different2 = np.setdiff1d(y,x)
# print()
# print("X -> Y",different1)
# print()
# print("Y -> X",different2)
# union = np.union1d(x,y)
# print()
# print("Union ->",union)
# in1 = np.in1d(x,y)
# print()
# print(in1)
# unique = np.unique(x)
# print()
# print(unique)
#Sorting
# x = np.random.randint(1,10,size=(10,))
# print(x)
# print(np.sort(x))
# print(sorted(x))#if we use the sort just a function it affects the array only this line.
# print(x)
# print()
# y = x = np.random.randint(1,10,size=(10,))
# print(y)
# y.sort()# if we use the sort just a method it affects the original array.
# print(y)

